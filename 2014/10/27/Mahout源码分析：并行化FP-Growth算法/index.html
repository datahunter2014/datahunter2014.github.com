<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mahout源码分析：并行化FP-Growth算法 | datahunter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="FP-Growth是一种常被用来进行关联分析，挖掘频繁项的算法。与Aprior算法相比，FP-Growth算法采用前缀树的形式来表征数据，减少了扫描事务数据库的次数，通过递归地生成条件FP-tree来挖掘频繁项。参考资料[1]详细分析了这一过程。事实上，面对大数据量时，FP-Growth算法生成的FP-tree非常大，无法放入内存，挖掘到的频繁项也可能有指数多个。本文将分析如何并行化FP-Gr">
<meta property="og:type" content="article">
<meta property="og:title" content="Mahout源码分析：并行化FP-Growth算法">
<meta property="og:url" content="http://yoursite.com/2014/10/27/Mahout源码分析：并行化FP-Growth算法/">
<meta property="og:site_name" content="datahunter">
<meta property="og:description" content="FP-Growth是一种常被用来进行关联分析，挖掘频繁项的算法。与Aprior算法相比，FP-Growth算法采用前缀树的形式来表征数据，减少了扫描事务数据库的次数，通过递归地生成条件FP-tree来挖掘频繁项。参考资料[1]详细分析了这一过程。事实上，面对大数据量时，FP-Growth算法生成的FP-tree非常大，无法放入内存，挖掘到的频繁项也可能有指数多个。本文将分析如何并行化FP-Gr">
<meta property="og:image" content="/img/201410281.png">
<meta property="og:image" content="/img/201410282.png">
<meta property="og:image" content="/img/201410283.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mahout源码分析：并行化FP-Growth算法">
<meta name="twitter:description" content="FP-Growth是一种常被用来进行关联分析，挖掘频繁项的算法。与Aprior算法相比，FP-Growth算法采用前缀树的形式来表征数据，减少了扫描事务数据库的次数，通过递归地生成条件FP-tree来挖掘频繁项。参考资料[1]详细分析了这一过程。事实上，面对大数据量时，FP-Growth算法生成的FP-tree非常大，无法放入内存，挖掘到的频繁项也可能有指数多个。本文将分析如何并行化FP-Gr">

  
    <link rel="alternative" href="/atom.xml" title="datahunter" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">datahunter</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Mahout源码分析：并行化FP-Growth算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/27/Mahout源码分析：并行化FP-Growth算法/" class="article-date">
  <time datetime="2014-10-27T13:19:25.000Z" itemprop="datePublished">2014-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Mahout源码分析：并行化FP-Growth算法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　FP-Growth是一种常被用来进行关联分析，挖掘频繁项的算法。与Aprior算法相比，FP-Growth算法采用前缀树的形式来表征数据，减少了扫描事务数据库的次数，通过递归地生成条件FP-tree来挖掘频繁项。参考资料[1]详细分析了这一过程。事实上，面对大数据量时，FP-Growth算法生成的FP-tree非常大，无法放入内存，挖掘到的频繁项也可能有指数多个。本文将分析如何并行化FP-Growth算法以及Mahout中并行化FP-Growth算法的源码。</p>
<h3 id="1-_并行化FP-Growth">1. 并行化FP-Growth</h3>
<p>　　并行化FP-Growth的方法有很多，最早提出使用MapReduce并行化FP-Growth算法的应该是来自Google Beijing Research的Haoyuan Li等。他们提出使用三次MapReduce来并行化FP-Growth，整个过程大致可以分为五个步骤：<br><strong> Step 1：Sharding </strong><br>　　为了均衡整个集群的读写性能，将事务数据库分成若干个数据片段(shard)，存储到P个节点中。</p>
<p><strong> Step 2：Parallel Counting </strong><br>　　与WordCount类似，通过一次MapReduce来计算每一个项(item)的支持度。具体来说，每一个mapper将从hdfs中取得事务数据库的若干个数据片段(shards)，所以mapper的输入是<key, value="Ti">，Ti表示数据片段中的一条数据。对于Ti中的每一个项aj，mapper输出<key=aj, value="1">。当集群中的所有mapper处理完数据之后，所有key=aj的键值对将被分配到同一个reducer，所以reducer的输入是<key=aj, value="{1," 1,="" ...="" ,="" 1}="">。reducer只需要进行一次求和，然后输出<key=aj, value="sum{1," 1,="" ...="" ,="" 1}="">。最终将得到一张按照支持度递减排序的列表，称之为F-List：</key=aj,></key=aj,></key=aj,></key,></p>
<img src="/img/201410281.png">

<center>图1</center> 

<p><strong> Step 3：Grouping Items </strong><br>　　将F-List中的项(item)分为Q个组(group)，每一个组都有一个唯一的group-id，我们将所有项以及其所对应的group-id记为G-List。</p>
<p><strong> Step 4：Parallel FP-Growth </strong><br>　　这一步骤是并行化FP-Growth的关键，也是整个算法中相对难以理解的部分。这一步骤中将用到一次MapReduce。每一个mapper的输入来自第一步生成的数据片段，所以mapper的输入是<key, value="Ti">。在处理这些数据片段之前，mapper将读取第三步生成的G-List。G-List其实是一张Hashmap，键是项，值是项所对应的group-id，所占空间一般并不会很大，可以放入内存中。从Ti的最后一项开始向前扫描，或者说从右向左扫描，如果aL在G-List中对应的group-id是第一次被扫描，则输出{a0，a1，…，aL}，否则不输出任何数据。以图1中所示的数据为例，假如支持度阈值为1，Q为3，那么将得到G-List:</key,></p>
<img src="/img/201410282.png">

<center>图2</center> 

<p>　　其中，第三列是group-id。假如mapper的输入是{牛奶，鸡蛋，面包，薯片}，从最后一项开始扫描，输出<key=1，value={牛奶，鸡蛋，面包，薯片}>。之后的两项是面包和鸡蛋，其所对应的group-id和薯片相同，所以不输出任何数据。第一项是牛奶，其所对应的group-id未曾出现过，所以输出<key=2，value={牛奶}>。</key=2，value={牛奶}></key=1，value={牛奶，鸡蛋，面包，薯片}></p>
<p>　　所有group-id相同的数据将被推送到同一个reducer，所以reducer的输入是<key=group-id，value=<{valuelist1}，{valuelist2}，…，{valuelistn}>&gt;。reducer在本地构建FP-tree，然后像传统的FP-Growth算法那样递归地构建条件FP-tree，并挖掘频繁模式。与传统的FP-Growth算法不一样的是，reducer并不直接输出所挖掘到的频繁模式，而是将其放入一个大小为K，根据支持度排序建立的大根堆，然后输出K个支持度较高的频繁模式：<key=item，reduce={包含该item的top k="" frequent="" patterns}="">。</key=item，reduce={包含该item的top></key=group-id，value=<{valuelist1}，{valuelist2}，…，{valuelistn}></p>
<p><strong> Step 5：Aggregating </strong></p>
<p>　　上一步挖掘到的频繁模式Top K Frequent Patterns已经包含了所有频繁模式，然而上一步的MapReduce是按照groupID来划分数据，因此key=item对应的频繁模式会存在于若干个不同groupID的reduce节点上。为了合并所有key=item的键值对，优化结果展现形式，可利用MapReduce默认对key排序的特点，对挖掘到的频繁模式进行一下处理：依次将Top K Frequent Patterns的每一个item作为key，然后输出包含该key的这一条Top K Frequent Patterns。所以，每一个mapper的输出是<key=item, value="{该节点上的包含该item的频繁模式}">，reducer汇总所有mapper的输出结果，并输出最终的结果<key=item, value="{包含该item的所有频繁模式}">。 </key=item,></key=item,></p>
<h3 id="2-_Parallel_FP-Growth源码分析">2. Parallel FP-Growth源码分析</h3>
<p>　　Mahout提供了一些机器学习领域经典算法的实现。Mahout0.9之后的版本已经移除了Parallel FP-Growth算法。本文将分析Mahout0.8中Parallel FP-Growth的源码。</p>
<img src="/img/201410283.png">

<center>图3</center> 

<p><strong> FPGrowthDriver.java </strong><br>　　FPGrowthDriver是FPGrowth算法的驱动类，继承自AbstractJob类。运行Hadoop任务一般都是通过命令行中执行bin/hadoop脚本，同时传入一些参数。ToolRunner类中的GenericOptionsParser可获取这些命令行参数。AbstractJob类封装了addInputOption，addOutputOption，addOption，parseArguments等方法，为解析命令行参数提供了帮助。params对象存储了整个算法所需要的参数。FPGrowthDriver根据命令行参数，若顺序执行，则调用该文件内的runFPGrowth方法，若并行化执行，则调用PFPGrowth.java文件中的runPFPGrowth方法。</p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FPGrowthDriver</span> <span class="keyword">extends</span> <span class="title">AbstractJob</span> </span>{</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(FPGrowthDriver.class);</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="title">FPGrowthDriver</span>() {</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line"><span class="comment">//ToolRunner的静态方法run()内有GenericOptionsParser。通过GenericOptionsParser.getRemainingArgs()可获取传入的命令行参数。之后，ToolRunner.run()将调用FPGrowthDriver.run()。</span></div><div class="line">    ToolRunner.run(<span class="keyword">new</span> Configuration(), <span class="keyword">new</span> FPGrowthDriver(), args);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="javadoc">/**</span></div><div class="line">   * Run TopK FPGrowth given the input file,</div><div class="line">   */</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">    addInputOption(); <span class="comment">//添加默认的输入目录路径</span></div><div class="line">    addOutputOption(); <span class="comment">//添加默认的输出目录路径</span></div><div class="line"></div><div class="line">    addOption(<span class="string">"minSupport"</span>, <span class="string">"s"</span>, <span class="string">"(Optional) The minimum number of times a co-occurrence must be present."</span></div><div class="line">              + <span class="string">" Default Value: 3"</span>, <span class="string">"3"</span>); <span class="comment">//添加支持度阈值</span></div><div class="line">    addOption(<span class="string">"maxHeapSize"</span>, <span class="string">"k"</span>, <span class="string">"(Optional) Maximum Heap Size k, to denote the requirement to mine top K items."</span></div><div class="line">              + <span class="string">" Default value: 50"</span>, <span class="string">"50"</span>); <span class="comment">//添加大根堆的大小</span></div><div class="line">    addOption(<span class="string">"numGroups"</span>, <span class="string">"g"</span>, <span class="string">"(Optional) Number of groups the features should be divided in the map-reduce version."</span></div><div class="line">              + <span class="string">" Doesn't work in sequential version Default Value:"</span> + PFPGrowth.NUM_GROUPS_DEFAULT,</div><div class="line">              Integer.toString(PFPGrowth.NUM_GROUPS_DEFAULT)); <span class="comment">//添加组数g</span></div><div class="line">    addOption(<span class="string">"splitterPattern"</span>, <span class="string">"regex"</span>, <span class="string">"Regular Expression pattern used to split given string transaction into"</span></div><div class="line">            + <span class="string">" itemsets. Default value splits comma separated itemsets.  Default Value:"</span></div><div class="line">            + <span class="string">" \"[ ,\\t]*[,|\\t][ ,\\t]*\" "</span>, <span class="string">"[ ,\t]*[,|\t][ ,\t]*"</span>); <span class="comment">//添加分隔符</span></div><div class="line">    addOption(<span class="string">"numTreeCacheEntries"</span>, <span class="string">"tc"</span>, <span class="string">"(Optional) Number of entries in the tree cache to prevent duplicate"</span></div><div class="line">            + <span class="string">" tree building. (Warning) a first level conditional FP-Tree might consume a lot of memory, "</span></div><div class="line">            + <span class="string">"so keep this value small, but big enough to prevent duplicate tree building. "</span></div><div class="line">            + <span class="string">"Default Value:5 Recommended Values: [5-10]"</span>, <span class="string">"5"</span>);</div><div class="line">    addOption(<span class="string">"method"</span>, <span class="string">"method"</span>, <span class="string">"Method of processing: sequential|mapreduce"</span>, <span class="string">"sequential"</span>); <span class="comment">//添加训练方法，顺序执行或并行执行</span></div><div class="line">    addOption(<span class="string">"encoding"</span>, <span class="string">"e"</span>, <span class="string">"(Optional) The file encoding.  Default value: UTF-8"</span>, <span class="string">"UTF-8"</span>); <span class="comment">//添加编码方式</span></div><div class="line">    addFlag(<span class="string">"useFPG2"</span>, <span class="string">"2"</span>, <span class="string">"Use an alternate FPG implementation"</span>);</div><div class="line"></div><div class="line"><span class="comment">//如果解析命令行参数失败，则退出</span></div><div class="line">    <span class="keyword">if</span> (parseArguments(args) == <span class="keyword">null</span>) {</div><div class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    Parameters params = <span class="keyword">new</span> Parameters();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hasOption(<span class="string">"minSupport"</span>)) {</div><div class="line">      String minSupportString = getOption(<span class="string">"minSupport"</span>);</div><div class="line">      params.set(<span class="string">"minSupport"</span>, minSupportString);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (hasOption(<span class="string">"maxHeapSize"</span>)) {</div><div class="line">      String maxHeapSizeString = getOption(<span class="string">"maxHeapSize"</span>);</div><div class="line">      params.set(<span class="string">"maxHeapSize"</span>, maxHeapSizeString);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (hasOption(<span class="string">"numGroups"</span>)) {</div><div class="line">      String numGroupsString = getOption(<span class="string">"numGroups"</span>);</div><div class="line">      params.set(<span class="string">"numGroups"</span>, numGroupsString);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hasOption(<span class="string">"numTreeCacheEntries"</span>)) {</div><div class="line">      String numTreeCacheString = getOption(<span class="string">"numTreeCacheEntries"</span>);</div><div class="line">      params.set(<span class="string">"treeCacheSize"</span>, numTreeCacheString);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hasOption(<span class="string">"splitterPattern"</span>)) {</div><div class="line">      String patternString = getOption(<span class="string">"splitterPattern"</span>);</div><div class="line">      params.set(<span class="string">"splitPattern"</span>, patternString);</div><div class="line">    }</div><div class="line"></div><div class="line">    String encoding = <span class="string">"UTF-8"</span>;</div><div class="line">    <span class="keyword">if</span> (hasOption(<span class="string">"encoding"</span>)) {</div><div class="line">      encoding = getOption(<span class="string">"encoding"</span>);</div><div class="line">    }</div><div class="line">    params.set(<span class="string">"encoding"</span>, encoding);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hasOption(<span class="string">"useFPG2"</span>)) {</div><div class="line">      params.set(PFPGrowth.USE_FPG2, <span class="string">"true"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Path inputDir = getInputPath();</div><div class="line">    Path outputDir = getOutputPath();</div><div class="line"></div><div class="line">    params.set(<span class="string">"input"</span>, inputDir.toString());</div><div class="line">    params.set(<span class="string">"output"</span>, outputDir.toString());</div><div class="line"></div><div class="line">    String classificationMethod = getOption(<span class="string">"method"</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="string">"sequential"</span>.equalsIgnoreCase(classificationMethod)) {</div><div class="line">      runFPGrowth(params);</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"mapreduce"</span>.equalsIgnoreCase(classificationMethod)) {</div><div class="line">      Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">      HadoopUtil.delete(conf, outputDir);</div><div class="line">      PFPGrowth.runPFPGrowth(params);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  }</div></pre></td></tr></table></figure>

<p><strong> PFPGrowth.java </strong><br>　　PFPGrowth是并行化FP-Growth算法的驱动类。runPFPGrowth(params)方法内初始化了一个Configuration对象，之后调用runPFPGrowth(params, conf)方法。runPFPGrowth(params, conf)方法包括了并行化FP-Growth算法的五个关键步骤。其中，startParallelCounting(params, conf)对应Step1和Step2，通过类似WordCount的方法统计每一项的支持度，其输出结果将被readFList()和saveList()用于生成FList。之后，将按照用户输入的命令行参数NUM_GROUPS来计算每一个group所含项的个数，并将其存储到params。startParallelFPGrowth(params, conf)对应Step3和Step4。startAggregating(params, conf)对应Step5。</p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runPFPGrowth</span>(Parameters <span class="keyword">params</span>, Configuration conf) throws IOException, InterruptedException, ClassNotFoundException {</div><div class="line">    conf.<span class="keyword">set</span>(<span class="string">"io.serializations"</span>, <span class="string">"org.apache.hadoop.io.serializer.JavaSerialization,"</span> + <span class="string">"org.apache.hadoop.io.serializer.WritableSerialization"</span>);</div><div class="line"></div><div class="line">    startParallelCounting(<span class="keyword">params</span>, conf); <span class="comment">//对应Step1和Step2</span></div><div class="line"></div><div class="line">    <span class="comment">// save feature list to dcache</span></div><div class="line">    List&lt;Pair&lt;String,Long&gt;&gt; fList = readFList(<span class="keyword">params</span>);</div><div class="line">    saveFList(fList, <span class="keyword">params</span>, conf);</div><div class="line"></div><div class="line">    <span class="comment">// set param to control group size in MR jobs</span></div><div class="line">    <span class="keyword">int</span> numGroups = <span class="keyword">params</span>.getInt(NUM_GROUPS, NUM_GROUPS_DEFAULT);</div><div class="line">    <span class="keyword">int</span> maxPerGroup = fList.size() / numGroups;</div><div class="line">    <span class="keyword">if</span> (fList.size() % numGroups != <span class="number">0</span>) {</div><div class="line">      maxPerGroup++;</div><div class="line">    }</div><div class="line">    <span class="keyword">params</span>.<span class="keyword">set</span>(MAX_PER_GROUP, Integer.toString(maxPerGroup));</div><div class="line"></div><div class="line">    startParallelFPGrowth(<span class="keyword">params</span>, conf); <span class="comment">//对应Step3和Step4</span></div><div class="line"></div><div class="line">    startAggregating(<span class="keyword">params</span>, conf); <span class="comment">//对应Step5</span></div><div class="line">  }</div></pre></td></tr></table></figure>

<p>　　startParallelCounting方法初始化了一个Job对象。该Job对象将调用ParallelCountingMapper和ParallelCountingReducer来完成支持度的统计。</p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Count the frequencies of various features in parallel using Map/Reduce</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> startParallelCounting(Parameters params, Configuration conf)</div><div class="line">    throws IOException, InterruptedException, ClassNotFoundException {</div><div class="line">    conf.<span class="keyword">set</span>(PFP_PARAMETERS, params.toString());</div><div class="line">    </div><div class="line">    conf.<span class="keyword">set</span>(<span class="string">"mapred.compress.map.output"</span>, <span class="string">"true"</span>);</div><div class="line">    conf.<span class="keyword">set</span>(<span class="string">"mapred.output.compression.type"</span>, <span class="string">"BLOCK"</span>);</div><div class="line">    </div><div class="line">    String input = params.<span class="keyword">get</span>(INPUT);</div><div class="line">    Job job = <span class="keyword">new</span> Job(conf, <span class="string">"Parallel Counting Driver running over input: "</span> + input);</div><div class="line">    job.setJarByClass(PFPGrowth.<span class="keyword">class</span>);</div><div class="line">    </div><div class="line">    job.setOutputKeyClass(Text.<span class="keyword">class</span>);</div><div class="line">    job.setOutputValueClass(LongWritable.<span class="keyword">class</span>);</div><div class="line">    </div><div class="line">    FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(input));</div><div class="line">    Path outPath = <span class="keyword">new</span> Path(params.<span class="keyword">get</span>(OUTPUT), PARALLEL_COUNTING);</div><div class="line">    FileOutputFormat.setOutputPath(job, outPath);</div><div class="line">    </div><div class="line">    HadoopUtil.<span class="keyword">delete</span>(conf, outPath);</div><div class="line">    </div><div class="line">    job.setInputFormatClass(TextInputFormat.<span class="keyword">class</span>);</div><div class="line">    job.setMapperClass(ParallelCountingMapper.<span class="keyword">class</span>);</div><div class="line">    job.setCombinerClass(ParallelCountingReducer.<span class="keyword">class</span>);</div><div class="line">    job.setReducerClass(ParallelCountingReducer.<span class="keyword">class</span>);</div><div class="line">    job.setOutputFormatClass(SequenceFileOutputFormat.<span class="keyword">class</span>);</div><div class="line">    </div><div class="line">    boolean succeeded = job.waitForCompletion(<span class="literal">true</span>);</div><div class="line">    <span class="keyword">if</span> (!succeeded) {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Job failed!"</span>);</div><div class="line">    }</div><div class="line">    </div><div class="line">  }</div></pre></td></tr></table></figure>

<p><strong> ParallelCountingMapper.java </strong><br>　　ParallelCountingMapper中map方法的输入分别是字节偏移量offset和事务数据库中的某一行数据input。所有input数据中多次出现的项都被视为出现一次，所以将input数据split之后存储到HashSet中。map方法的输出是<key=item, value="one">。</key=item,></p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelCountingMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>{</div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LongWritable ONE = <span class="keyword">new</span> LongWritable(<span class="number">1</span>);</div><div class="line">  </div><div class="line">    <span class="keyword">private</span> Pattern splitter;</div><div class="line">  </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span>(LongWritable offset, Text input, Context context) <span class="keyword">throws</span> IOException, InterruptedException {</div><div class="line">    </div><div class="line">    String[] items = splitter.split(input.toString());</div><div class="line">    Set&lt;String&gt; uniqueItems = Sets.newHashSet(Arrays.asList(items));</div><div class="line">    <span class="keyword">for</span> (String item : uniqueItems) {</div><div class="line">      <span class="keyword">if</span> (item.trim().isEmpty()) {</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      }</div><div class="line">      context.setStatus(<span class="string">"Parallel Counting Mapper: "</span> + item);</div><div class="line">      context.write(<span class="keyword">new</span> Text(item), ONE);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setup</span>(Context context) <span class="keyword">throws</span> IOException, InterruptedException {</div><div class="line">    <span class="keyword">super</span>.setup(context);</div><div class="line">    Parameters params = <span class="keyword">new</span> Parameters(context.getConfiguration().get(PFPGrowth.PFP_PARAMETERS, <span class="string">""</span>));</div><div class="line">    splitter = Pattern.compile(params.get(PFPGrowth.SPLIT_PATTERN, PFPGrowth.SPLITTER.toString()));</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong> ParallelCountingReducer.java </strong><br>　　ParallelCountingReducer中reduce方法的输入是<key=item, value="{one," one,="" ...="" ,="" one}="">。所有key=item的键值对将被分配到一台机器上，所以只需要对values进行遍历求和就可以求出该item的支持度。</key=item,></p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelCountingReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>{</div><div class="line">  </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span>(Text key, Iterable&lt;LongWritable&gt; values, Context context) <span class="keyword">throws</span> IOException,</div><div class="line">                                                                                 InterruptedException {</div><div class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (LongWritable value : values) {</div><div class="line">      context.setStatus(<span class="string">"Parallel Counting Reducer :"</span> + key);</div><div class="line">      sum += value.get();</div><div class="line">    }</div><div class="line">    context.setStatus(<span class="string">"Parallel Counting Reducer: "</span> + key + <span class="string">" =&gt; "</span> + sum);</div><div class="line">    context.write(key, <span class="keyword">new</span> LongWritable(sum));</div><div class="line">    </div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong> PFPGrowth.java </strong><br>　　通过params中的OUTPUT参数可以获取ParallelCountingReducer的输出路径。在readFList这个方法中用到了几个数据结构。Pair实现了Comparable接口和Serializable接口，其数据成员first和second分别用来表示item和item所对应的支持度。PriorityQueue是一个用平衡二叉树实现的小顶堆，如果指定了Comparator，将按照Comparator对PriorityQueue中的元素进行排序，如果未指定Comparator，则将按照元素实现的Comparable接口进行排序。在并行化FP-Growth算法中，初始化PriorityQueue时指定了Comparator，其按照Pair的第一个元素进行排序，如果第一个元素相等，则按照第二个元素进行排序。通过初始化SequenceFileDirIterable来遍历上一次MapReduce输出的结果，每次将Pair添加到PriorityQueue的同时完成排序。最后，逐一将PriorityQueue中的元素取出放入fList。因此，fList是一个按照支持度递减的列表。</p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * read the feature frequency List which is built at the end of the Parallel counting job</div><div class="line">   * </div><div class="line">   * @return Feature Frequency List</div><div class="line">   */</div><div class="line">    <span class="keyword">public</span> static <span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>,Long<span class="subst">&gt;&gt;</span> readFList(Parameters <span class="keyword">params</span>) {</div><div class="line">    int minSupport <span class="subst">=</span> <span class="built_in">Integer</span><span class="built_in">.</span>valueOf(<span class="keyword">params</span><span class="built_in">.</span>get(MIN_SUPPORT, <span class="string">"3"</span>));</div><div class="line">    Configuration conf <span class="subst">=</span> <span class="literal">new</span> Configuration();</div><div class="line">    </div><div class="line">    Path parallelCountingPath <span class="subst">=</span> <span class="literal">new</span> Path(<span class="keyword">params</span><span class="built_in">.</span>get(OUTPUT), PARALLEL_COUNTING);</div><div class="line"></div><div class="line">    PriorityQueue<span class="subst">&lt;</span><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>,Long<span class="subst">&gt;&gt;</span> <span class="built_in">queue</span> <span class="subst">=</span> <span class="literal">new</span> PriorityQueue<span class="subst">&lt;</span><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>,Long<span class="subst">&gt;&gt;</span>(<span class="number">11</span>,</div><div class="line">        <span class="literal">new</span> Comparator<span class="subst">&lt;</span><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>,Long<span class="subst">&gt;&gt;</span>() {</div><div class="line">          @Override</div><div class="line">          <span class="keyword">public</span> int compare(<span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>,Long<span class="subst">&gt;</span> o1, <span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>,Long<span class="subst">&gt;</span> o2) {</div><div class="line">            int ret <span class="subst">=</span> o2<span class="built_in">.</span>getSecond()<span class="built_in">.</span>compareTo(o1<span class="built_in">.</span>getSecond());</div><div class="line">            <span class="keyword">if</span> (ret <span class="subst">!=</span> <span class="number">0</span>) {</div><div class="line">              <span class="keyword">return</span> ret;</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> o1<span class="built_in">.</span>getFirst()<span class="built_in">.</span>compareTo(o2<span class="built_in">.</span>getFirst());</div><div class="line">          }</div><div class="line">        });</div><div class="line"></div><div class="line">    for (<span class="built_in">Pair</span><span class="subst">&lt;</span>Text,LongWritable<span class="subst">&gt;</span> record</div><div class="line">         : <span class="literal">new</span> SequenceFileDirIterable<span class="subst">&lt;</span>Text,LongWritable<span class="subst">&gt;</span>(<span class="literal">new</span> Path(parallelCountingPath, FILE_PATTERN),</div><div class="line">                                                        PathType<span class="built_in">.</span>GLOB, <span class="built_in">null</span>, <span class="built_in">null</span>, <span class="literal">true</span>, conf)) {</div><div class="line">      long value <span class="subst">=</span> record<span class="built_in">.</span>getSecond()<span class="built_in">.</span>get();</div><div class="line">      <span class="keyword">if</span> (value <span class="subst">&gt;=</span> minSupport) {</div><div class="line">        <span class="built_in">queue</span><span class="built_in">.</span>add(<span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>,Long<span class="subst">&gt;</span>(record<span class="built_in">.</span>getFirst()<span class="built_in">.</span>toString(), value));</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>,Long<span class="subst">&gt;&gt;</span> fList <span class="subst">=</span> Lists<span class="built_in">.</span>newArrayList();</div><div class="line">    <span class="keyword">while</span> (<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty()) {</div><div class="line">      fList<span class="built_in">.</span>add(<span class="built_in">queue</span><span class="built_in">.</span>poll());</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> fList;</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>　　由于已经生成了fList，上一次MapReduce的输出结果已经没有用了，因此，saveFList方法首先删除了这些文件。之后，saveFList方法将flist写入到hdfs上。对于存储在hdfs上的文件，DistributedCache提供了缓存文件的功能，在Slave Node进行计算之前可将hdfs上的文件复制到这些节点上。</p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line">   * Serializes the fList and returns the string representation of the List</div><div class="line">   */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveFList</span>(Iterable&lt;Pair&lt;String,Long&gt;&gt; flist, Parameters params, Configuration conf)</div><div class="line">    <span class="keyword">throws</span> IOException {</div><div class="line">    Path flistPath = <span class="keyword">new</span> Path(params.get(OUTPUT), F_LIST);</div><div class="line">    FileSystem fs = FileSystem.get(flistPath.toUri(), conf);</div><div class="line">    flistPath = fs.makeQualified(flistPath);</div><div class="line">    HadoopUtil.delete(conf, flistPath);</div><div class="line">    SequenceFile.Writer writer = <span class="keyword">new</span> SequenceFile.Writer(fs, conf, flistPath, Text.class, LongWritable.class);</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">    　　<span class="keyword">for</span> (Pair&lt;String,Long&gt; pair : flist) {</div><div class="line">        writer.append(<span class="keyword">new</span> Text(pair.getFirst()), <span class="keyword">new</span> LongWritable(pair.getSecond()));</div><div class="line">      }</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">      writer.close();</div><div class="line">    }</div><div class="line">    DistributedCache.addCacheFile(flistPath.toUri(), conf);</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>　　startParallelFPGrowth方法初始化了一个Job对象。该Job对象将调用ParallelFPGrowthMapper和ParallelFPGrowthReducer来实现Step3和Step4。</p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Run the Parallel FPGrowth Map/Reduce Job to calculate the Top K features of group dependent shards</div><div class="line">   */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> startParallelFPGrowth(Parameters params, Configuration conf)</div><div class="line">    throws IOException, InterruptedException, ClassNotFoundException {</div><div class="line">    conf.<span class="keyword">set</span>(PFP_PARAMETERS, params.toString());</div><div class="line">    conf.<span class="keyword">set</span>(<span class="string">"mapred.compress.map.output"</span>, <span class="string">"true"</span>);</div><div class="line">    conf.<span class="keyword">set</span>(<span class="string">"mapred.output.compression.type"</span>, <span class="string">"BLOCK"</span>);</div><div class="line">    Path input = <span class="keyword">new</span> Path(params.<span class="keyword">get</span>(INPUT));</div><div class="line">    Job job = <span class="keyword">new</span> Job(conf, <span class="string">"PFP Growth Driver running over input"</span> + input);</div><div class="line">    job.setJarByClass(PFPGrowth.<span class="keyword">class</span>);</div><div class="line">    </div><div class="line">    job.setMapOutputKeyClass(IntWritable.<span class="keyword">class</span>);</div><div class="line">    job.setMapOutputValueClass(TransactionTree.<span class="keyword">class</span>);</div><div class="line">    </div><div class="line">    job.setOutputKeyClass(Text.<span class="keyword">class</span>);</div><div class="line">    job.setOutputValueClass(TopKStringPatterns.<span class="keyword">class</span>);</div><div class="line">    </div><div class="line">    FileInputFormat.addInputPath(job, input);</div><div class="line">    Path outPath = <span class="keyword">new</span> Path(params.<span class="keyword">get</span>(OUTPUT), FPGROWTH);</div><div class="line">    FileOutputFormat.setOutputPath(job, outPath);</div><div class="line">    </div><div class="line">    HadoopUtil.<span class="keyword">delete</span>(conf, outPath);</div><div class="line">    </div><div class="line">    job.setInputFormatClass(TextInputFormat.<span class="keyword">class</span>);</div><div class="line">    job.setMapperClass(ParallelFPGrowthMapper.<span class="keyword">class</span>);</div><div class="line">    job.setCombinerClass(ParallelFPGrowthCombiner.<span class="keyword">class</span>);</div><div class="line">    job.setReducerClass(ParallelFPGrowthReducer.<span class="keyword">class</span>);</div><div class="line">    job.setOutputFormatClass(SequenceFileOutputFormat.<span class="keyword">class</span>);</div><div class="line">    </div><div class="line">    boolean succeeded = job.waitForCompletion(<span class="literal">true</span>);</div><div class="line">    <span class="keyword">if</span> (!succeeded) {</div><div class="line">      　<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Job failed!"</span>);</div><div class="line">    }</div><div class="line">  }</div></pre></td></tr></table></figure>

<p><strong> ParallelFPGrowthMapper.java </strong><br>　　ParallelFPGrowthMapper中的setup方法将在map方法之前被运行。setup方法中调用了readFList方法。注意这里的readFList方法与之前分析的readFList方法参数不一样，所以是两个完全不同的方法。这里的readFList方法通过HadoopUtil.getCachedFiles(conf)来获取缓存文件flist，将其存储到fMap，其中item作为fMap的键，item在flist中的位置序号作为fMap的值，例如flist中的第一个item，其在fMap中将是<key=item, value="0">。这样做的原因是之后将fMap分Q个group时需要用到这个位置序号。在map方法中，输入是字节偏移量和事务数据库中的某一行数据。根据用户指定的分隔符splitter来切分数据。为了过滤非频繁项，通过fMap.containsKey(item)方法来查找该项是否存在于fList中。若存在，将其所对应的位置序号加入到itemSet，否则，将其丢弃。itemArr复制itemSet中的数据，并按照位置序号递增进行排序，即按照支持度递减进行排序。之后的for循环从itemArr的最后一个元素向前遍历，如果其所对应的groupID不在groups中，那么将初始化TransactionTree，将itemArr[0]，itemArr[1]，…，itemArr[j]存入该TransactionTree中。groupID的计算非常简单，将位置序号除以maxPerGroup即可。TransactionTree实现了Writable和Iterable<pair<intarraylist, long="">&gt;接口，初始化TransactionTree时，构造方法将参数赋值给TransactionTree中的数据成员List<pair<intarraylist, long="">&gt; transactionSet。这里Pair对象存储的两个元素分别是位置序号列表和1。</pair<intarraylist,></pair<intarraylist,></key=item,></p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> *  maps each transaction to all unique items groups in the transaction. mapper</div><div class="line"> * outputs the group id as key and the transaction as value</div><div class="line"> * </div><div class="line"> */</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelFPGrowthMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>,<span class="title">TransactionTree</span>&gt; </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OpenObjectIntHashMap&lt;String&gt; fMap = <span class="keyword">new</span> OpenObjectIntHashMap&lt;String&gt;();</div><div class="line">    <span class="keyword">private</span> Pattern splitter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPerGroup;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IntWritable wGroupID = <span class="keyword">new</span> IntWritable();</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span>(LongWritable offset, Text input, Context context)</div><div class="line">    <span class="keyword">throws</span> IOException, InterruptedException {</div><div class="line"></div><div class="line">    String[] items = splitter.split(input.toString());</div><div class="line"></div><div class="line">    OpenIntHashSet itemSet = <span class="keyword">new</span> OpenIntHashSet();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (String item : items) {</div><div class="line">      <span class="keyword">if</span> (fMap.containsKey(item) && !item.trim().isEmpty()) {</div><div class="line">        itemSet.add(fMap.get(item));</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">    IntArrayList itemArr = <span class="keyword">new</span> IntArrayList(itemSet.size());</div><div class="line">    itemSet.keys(itemArr);</div><div class="line">    itemArr.sort();</div><div class="line"></div><div class="line">    OpenIntHashSet groups = <span class="keyword">new</span> OpenIntHashSet();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = itemArr.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) {</div><div class="line">      <span class="comment">// generate group dependent shards</span></div><div class="line">      <span class="keyword">int</span> item = itemArr.get(j);</div><div class="line">      <span class="keyword">int</span> groupID = PFPGrowth.getGroup(item, maxPerGroup);</div><div class="line">        </div><div class="line">      <span class="keyword">if</span> (!groups.contains(groupID)) {</div><div class="line">        IntArrayList tempItems = <span class="keyword">new</span> IntArrayList(j + <span class="number">1</span>);</div><div class="line">        tempItems.addAllOfFromTo(itemArr, <span class="number">0</span>, j);</div><div class="line">        context.setStatus(<span class="string">"Parallel FPGrowth: Generating Group Dependent transactions for: "</span> + item);</div><div class="line">        wGroupID.set(groupID);</div><div class="line">        context.write(wGroupID, <span class="keyword">new</span> TransactionTree(tempItems, <span class="number">1</span>L));</div><div class="line">      }</div><div class="line">      groups.add(groupID);</div><div class="line">    }</div><div class="line">    </div><div class="line">  }</div><div class="line">  </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setup</span>(Context context) <span class="keyword">throws</span> IOException, InterruptedException {</div><div class="line">    <span class="keyword">super</span>.setup(context);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Pair&lt;String,Long&gt; e : PFPGrowth.readFList(context.getConfiguration())) {</div><div class="line">      fMap.put(e.getFirst(), i++);</div><div class="line">    }</div><div class="line">    </div><div class="line">    Parameters params = </div><div class="line">      <span class="keyword">new</span> Parameters(context.getConfiguration().get(PFPGrowth.PFP_PARAMETERS, <span class="string">""</span>));</div><div class="line"></div><div class="line">    splitter = Pattern.compile(params.get(PFPGrowth.SPLIT_PATTERN,</div><div class="line">                                          PFPGrowth.SPLITTER.toString()));</div><div class="line">    </div><div class="line">    maxPerGroup = params.getInt(PFPGrowth.MAX_PER_GROUP, <span class="number">0</span>);</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong> ParallelFPGrowthReducer.java </strong><br> 　　ParallelFPGrowthReducer的输入是<key=groupid, value="{TransactionTree1," transactiontree2,="" …="" ,="" transactiontreen}="">。setup方法获取了参数params，并且通过PFPGrowth.readFList(conf)方法获取了缓存文件flist，将频繁项存入featureReverseMap，将频繁项对应的支持度存入freqList。之前分析到ParallelFPGrowthMapper输出的TransactionTree其实是List<pair<intarraylist, long="">&gt; transactionSet。在ParallelFPGrowthReducer内初始化了一个TransactionTree，虽然这个TransactionTree与之前的Transaction是同一个类，但是是一棵用二维数组实现的树。考虑到文章篇幅，建树的过程这里不作分析。假设已经建好了这棵树，cTree.generateFList方法遍历这棵树，返回Map<integer, mutablelong=""> frequencyList。具体的遍历方法这里不作详细分析，提一下其调用过程：TransactionTree实现Iterator<pair<intarraylist, long="">&gt;接口时重写了iterator方法，在generateFList方法中通过iterator方法生成一个迭代器来遍历整棵树。iterator方法返回的是TransactionTreeIterator对象。TransactionTreeIterator对象继承自AbstractIterator<pair<intarraylist, long="">&gt;，实现了对TransactionTree进行遍历。localFList合并了generateFList的结果并按照支持度递减进行排序。生成频繁模式的方法有两种，用户可以自己选择来调用FPGrowthIds.generateTopKFrequentPatterns方法或者fpGrowth.generateTopKFrequentPatterns方法来生成频繁模式，本文将对后者进行分析。在ParallelFPGrowthReducer中还有一个IteratorAdapter类。它是设计模式中十分经典的适配器模式的具体应用，可以将两个不同类型的迭代器解耦。ParallelFPGrowthReducer的输出是<key=item, value="{Top" k="" frequent="" patterns}="">。</key=item,></pair<intarraylist,></pair<intarraylist,></integer,></pair<intarraylist,></key=groupid,></p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> *  takes each group of transactions and runs Vanilla FPGrowth on it and</div><div class="line"> * outputs the the Top K frequent Patterns for each group.</div><div class="line"> * </div><div class="line"> */</div><div class="line">　　 <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelFPGrowthReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">IntWritable</span>,<span class="title">TransactionTree</span>,<span class="title">Text</span>,<span class="title">TopKStringPatterns</span>&gt; </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; featureReverseMap = Lists.newArrayList();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongArrayList freqList = <span class="keyword">new</span> LongArrayList();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxHeapSize = <span class="number">50</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minSupport = <span class="number">3</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numFeatures;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPerGroup;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> useFP2;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorAdapter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Pair</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;,<span class="title">Long</span>&gt;&gt; </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;Pair&lt;IntArrayList,Long&gt;&gt; innerIter;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="title">IteratorAdapter</span>(Iterator&lt;Pair&lt;IntArrayList,Long&gt;&gt; transactionIter) {</div><div class="line">      innerIter = transactionIter;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span>() {</div><div class="line">      <span class="keyword">return</span> innerIter.hasNext();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> Pair&lt;List&lt;Integer&gt;,Long&gt; <span class="title">next</span>() {</div><div class="line">      Pair&lt;IntArrayList,Long&gt; innerNext = innerIter.next();</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;List&lt;Integer&gt;,Long&gt;(innerNext.getFirst().toList(), innerNext.getSecond());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>() {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span>(IntWritable key, Iterable&lt;TransactionTree&gt; values, Context context) <span class="keyword">throws</span> IOException {</div><div class="line">    TransactionTree cTree = <span class="keyword">new</span> TransactionTree();</div><div class="line">    <span class="keyword">for</span> (TransactionTree tr : values) {</div><div class="line">      <span class="keyword">for</span> (Pair&lt;IntArrayList,Long&gt; p : tr) {</div><div class="line">        cTree.addPattern(p.getFirst(), p.getSecond());</div><div class="line">      }</div><div class="line">    }</div><div class="line">    </div><div class="line">    List&lt;Pair&lt;Integer,Long&gt;&gt; localFList = Lists.newArrayList();</div><div class="line">    <span class="keyword">for</span> (Entry&lt;Integer,MutableLong&gt; fItem : cTree.generateFList().entrySet()) {</div><div class="line">      localFList.add(<span class="keyword">new</span> Pair&lt;Integer,Long&gt;(fItem.getKey(), fItem.getValue().toLong()));</div><div class="line">    }</div><div class="line">    </div><div class="line">    Collections.sort(localFList, <span class="keyword">new</span> CountDescendingPairComparator&lt;Integer,Long&gt;());</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (useFP2) {</div><div class="line">      FPGrowthIds.generateTopKFrequentPatterns(</div><div class="line">          cTree.iterator(),</div><div class="line">          freqList,</div><div class="line">          minSupport,</div><div class="line">          maxHeapSize,</div><div class="line">          PFPGrowth.getGroupMembers(key.get(), maxPerGroup, numFeatures),</div><div class="line">          <span class="keyword">new</span> IntegerStringOutputConverter(</div><div class="line">              <span class="keyword">new</span> ContextWriteOutputCollector&lt;IntWritable, TransactionTree, Text, TopKStringPatterns&gt;(context),</div><div class="line">              featureReverseMap),</div><div class="line">          <span class="keyword">new</span> ContextStatusUpdater&lt;IntWritable, TransactionTree, Text, TopKStringPatterns&gt;(context));</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">      FPGrowth&lt;Integer&gt; fpGrowth = <span class="keyword">new</span> FPGrowth&lt;Integer&gt;();</div><div class="line">      fpGrowth.generateTopKFrequentPatterns(</div><div class="line">          <span class="keyword">new</span> IteratorAdapter(cTree.iterator()),</div><div class="line">          localFList,</div><div class="line">          minSupport,</div><div class="line">          maxHeapSize,</div><div class="line">          Sets.newHashSet(PFPGrowth.getGroupMembers(key.get(),</div><div class="line">                                                         maxPerGroup, </div><div class="line">                                                         numFeatures).toList()),</div><div class="line">          <span class="keyword">new</span> IntegerStringOutputConverter(</div><div class="line">              <span class="keyword">new</span> ContextWriteOutputCollector&lt;IntWritable,TransactionTree,Text,TopKStringPatterns&gt;(context),</div><div class="line">              featureReverseMap),</div><div class="line">          <span class="keyword">new</span> ContextStatusUpdater&lt;IntWritable,TransactionTree,Text,TopKStringPatterns&gt;(context));</div><div class="line">    }</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setup</span>(Context context) <span class="keyword">throws</span> IOException, InterruptedException {</div><div class="line">    </div><div class="line">    <span class="keyword">super</span>.setup(context);</div><div class="line">    Parameters params = <span class="keyword">new</span> Parameters(context.getConfiguration().get(PFPGrowth.PFP_PARAMETERS, <span class="string">""</span>));</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (Pair&lt;String,Long&gt; e : PFPGrowth.readFList(context.getConfiguration())) {</div><div class="line">      featureReverseMap.add(e.getFirst());</div><div class="line">      freqList.add(e.getSecond());</div><div class="line">    }</div><div class="line">    </div><div class="line">    maxHeapSize = Integer.valueOf(params.get(PFPGrowth.MAX_HEAPSIZE, <span class="string">"50"</span>));</div><div class="line">    minSupport = Integer.valueOf(params.get(PFPGrowth.MIN_SUPPORT, <span class="string">"3"</span>));</div><div class="line"></div><div class="line">    maxPerGroup = params.getInt(PFPGrowth.MAX_PER_GROUP, <span class="number">0</span>);</div><div class="line">    numFeatures = featureReverseMap.size();</div><div class="line">    useFP2 = <span class="string">"true"</span>.equals(params.get(PFPGrowth.USE_FPG2));</div><div class="line">  }</div></pre></td></tr></table></figure>

<p><strong> TransactionTree.java </strong><br>　　在分析fpGrowth.generateTopKFrequentPatterns方法之前，先来分析一下建树过程中使用的addPattern方法。下面的代码列出了TransactionTree的数据成员和addPattern方法。在addPattern方法中，首先从根节点开始与myList中的节点进行比较。childWithAttribute返回temp节点下的孩子节点中是否有和attributeValue名称相同的节点。如果没有，addCountMode置为false，将myList中剩余的节点添加到这棵树中；如果有，则通过addCount方法增加child节点的支持度。这一建树的思路与传统的FP-Growth中建树的思路完全一致。</p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] attribute; <span class="comment">//节点的名称属性</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] childCount; <span class="comment">//对该节点的有多少个孩子节点进行计数</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[][] nodeChildren; <span class="comment">//二维数组，记录每一个节点的孩子节点</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">long</span>[] nodeCount; <span class="comment">//当前节点的支持度计数</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> nodes;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> representedAsList; <span class="comment">//true表示以List形式展现，false表示以树的形式展现</span></div><div class="line">  <span class="keyword">private</span> List&lt;Pair&lt;IntArrayList,Long&gt;&gt; transactionSet;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addPattern</span>(IntArrayList myList, <span class="keyword">long</span> addCount) {</div><div class="line">    <span class="keyword">int</span> temp = ROOTNODEID;</div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> addCountMode = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; myList.size(); idx++) {</div><div class="line">      <span class="keyword">int</span> attributeValue = myList.get(idx);</div><div class="line">      <span class="keyword">int</span> child;</div><div class="line">      <span class="keyword">if</span> (addCountMode) {</div><div class="line">        child = childWithAttribute(temp, attributeValue);</div><div class="line">        <span class="keyword">if</span> (child == -<span class="number">1</span>) {</div><div class="line">          addCountMode = <span class="keyword">false</span>;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">          addCount(child, addCount);</div><div class="line">          temp = child;</div><div class="line">        }</div><div class="line">      }</div><div class="line">      <span class="keyword">if</span> (!addCountMode) {</div><div class="line">        child = createNode(temp, attributeValue, addCount);</div><div class="line">        temp = child;</div><div class="line">        ret++;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">  }</div></pre></td></tr></table></figure>

<p><strong> FPGrowth.java </strong><br>　　generateTopKFrequentPatterns方法的形参有transactionStream，frequencyList，minSupport，k，Collection<a> returnableFeatures，OutputCollector<a, list<pair<list<a="">, Long&gt;&gt;&gt; output，Statusupdater updater。其中，transactionStream是根据当前key=groupID所对应的Pair<list<a>, Long&gt;类型的values建立的cTree，这里Pair的第一项是位置序号，第二项是1；frequencyList是ParallelFPGrowthReducer中的localFList，其第一项是位置序号，第二项是支持度；Collection<a> returnableFeatures是当前key=group-id所包含的位置序号集合。</a></list<a></a,></a></p>
<p>　　attributeIdMapping过滤了transactionStream中的非频繁项，并为频繁项分配新id，将其映射成<key=位置序号, value="id">。reverseMapping倒置了attributeIdMapping的映射关系。attributeFrequentcy记录了索引为id的项的支持度。对于returnableFeatures中的位置序号进行遍历，过滤非频繁项，returnFeatures记录了剩余的频繁项。之后调用generateTopKFrequentPatterns方法来构建本地的FP-tree和头表(Header-Table)，并遍历FP-tree来输出频繁项。参考资料[1]详细分析了这一过程，这里不作进一步分析，需要注意到是在Mahout中FP-tree是以数组的形式存储。</key=位置序号,></p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * Generate Top K Frequent Patterns <span class="keyword">for</span> <span class="keyword">every</span> feature <span class="keyword">in</span> returnableFeatures</div><div class="line">   * <span class="keyword">given</span> a stream <span class="keyword">of</span> transactions <span class="keyword">and</span> <span class="keyword">the</span> minimum support</div><div class="line">   *</div><div class="line">   * @param transactionStream</div><div class="line">   *          Iterator <span class="keyword">of</span> <span class="keyword">transaction</span></div><div class="line">   * @param frequencyList</div><div class="line">   *          <span class="type">list</span> <span class="keyword">of</span> frequent features <span class="keyword">and</span> their support value</div><div class="line">   * @param minSupport</div><div class="line">   *          minimum support <span class="keyword">of</span> <span class="keyword">the</span> transactions</div><div class="line">   * @param k</div><div class="line">   *          Number <span class="keyword">of</span> top frequent patterns <span class="keyword">to</span> keep</div><div class="line">   * @param returnableFeatures</div><div class="line">   *          <span class="keyword">set</span> <span class="keyword">of</span> features <span class="keyword">for</span> which <span class="keyword">the</span> frequent patterns are mined. If <span class="keyword">the</span></div><div class="line">   *          <span class="keyword">set</span> <span class="keyword">is</span> empty <span class="keyword">or</span> null, <span class="keyword">then</span> top K patterns <span class="keyword">for</span> <span class="keyword">every</span> frequent <span class="property">item</span> (an <span class="property">item</span></div><div class="line">   *          <span class="keyword">whose</span> support&gt; minSupport) <span class="keyword">is</span> generated</div><div class="line">   * @param output</div><div class="line">   *          The output collector <span class="keyword">to</span> which <span class="keyword">the</span> <span class="keyword">the</span> generated patterns are</div><div class="line">   *          written</div><div class="line">   * @throws IOException</div><div class="line">   */</div><div class="line">  public final void generateTopKFrequentPatterns(Iterator&lt;Pair&lt;List&lt;A&gt;,Long&gt;&gt; transactionStream,</div><div class="line">                                                 Collection&lt;Pair&lt;A, Long&gt;&gt; frequencyList,</div><div class="line">                                                 long minSupport,</div><div class="line">                                                 int k,</div><div class="line">                                                 Collection&lt;A&gt; returnableFeatures,</div><div class="line">                                                 OutputCollector&lt;A,List&lt;Pair&lt;List&lt;A&gt;,Long&gt;&gt;&gt; output,</div><div class="line">                                                 StatusUpdater updater) throws IOException {</div><div class="line"></div><div class="line">    Map&lt;Integer,A&gt; reverseMapping = Maps.newHashMap();</div><div class="line">    Map&lt;A,Integer&gt; attributeIdMapping = Maps.newHashMap();</div><div class="line"></div><div class="line">    int <span class="property">id</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Pair&lt;A,Long&gt; feature : frequencyList) {</div><div class="line">      A attrib = feature.getFirst();</div><div class="line">      Long frequency = feature.getSecond();</div><div class="line">      <span class="keyword">if</span> (frequency &gt;= minSupport) {</div><div class="line">        attributeIdMapping.<span class="keyword">put</span>(attrib, <span class="property">id</span>);</div><div class="line">        reverseMapping.<span class="keyword">put</span>(<span class="property">id</span>++, attrib);</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">    long[] attributeFrequency = new long[attributeIdMapping.size()];</div><div class="line">    <span class="keyword">for</span> (Pair&lt;A,Long&gt; feature : frequencyList) {</div><div class="line">      A attrib = feature.getFirst();</div><div class="line">      Long frequency = feature.getSecond();</div><div class="line">      <span class="keyword">if</span> (frequency &lt; minSupport) {</div><div class="line">        break;</div><div class="line">      }</div><div class="line">      attributeFrequency[attributeIdMapping.<span class="keyword">get</span>(attrib)] = frequency;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="command">log</span>.info(<span class="string">"Number of unique items {}"</span>, frequencyList.size());</div><div class="line"></div><div class="line">    Collection&lt;Integer&gt; returnFeatures = Sets.newHashSet();</div><div class="line">    <span class="keyword">if</span> (returnableFeatures != null && !returnableFeatures.isEmpty()) {</div><div class="line">      <span class="keyword">for</span> (A attrib : returnableFeatures) {</div><div class="line">        <span class="keyword">if</span> (attributeIdMapping.containsKey(attrib)) {</div><div class="line">          returnFeatures.add(attributeIdMapping.<span class="keyword">get</span>(attrib));</div><div class="line">          <span class="command">log</span>.info(<span class="string">"Adding Pattern {}=&gt;{}"</span>, attrib, attributeIdMapping</div><div class="line">            .<span class="keyword">get</span>(attrib));</div><div class="line">        }</div><div class="line">      }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">      <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; attributeIdMapping.size(); j++) {</div><div class="line">        returnFeatures.add(j);</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="command">log</span>.info(<span class="string">"Number of unique pruned items {}"</span>, attributeIdMapping.size());</div><div class="line">    generateTopKFrequentPatterns(new TransactionIterator&lt;A&gt;(transactionStream,</div><div class="line">        attributeIdMapping), attributeFrequency, minSupport, k, reverseMapping</div><div class="line">        .size(), returnFeatures, new TopKPatternsOutputConverter&lt;A&gt;(output,</div><div class="line">            reverseMapping), updater);</div><div class="line"></div><div class="line">  }</div></pre></td></tr></table></figure>

<p>　　AggregatorMapper的输入是<key, value="TopKStringPatterns">，TopKStringPatterns是一个存储<pair<list<string>,Long&gt;&gt;类型的列表，List<string>类型元素记录了每一个key=item对应的频繁模式，Long类型元素记录了支持度。</string></pair<list<string></key,></p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * </div><div class="line"> *  outputs the pattern for each item in the pattern, so that reducer can group them</div><div class="line"> * and select the top K frequent patterns</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AggregatorMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Text</span>,<span class="title">TopKStringPatterns</span>,<span class="title">Text</span>,<span class="title">TopKStringPatterns</span>&gt; </span>{</div><div class="line">  </div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span>(Text key, TopKStringPatterns values, Context context) <span class="keyword">throws</span> IOException,</div><div class="line">                                                                          InterruptedException {</div><div class="line">    <span class="keyword">for</span> (Pair&lt;List&lt;String&gt;,Long&gt; pattern : values.getPatterns()) {</div><div class="line">      <span class="keyword">for</span> (String item : pattern.getFirst()) {</div><div class="line">        List&lt;Pair&lt;List&lt;String&gt;,Long&gt;&gt; patternSingularList = Lists.newArrayList();</div><div class="line">        patternSingularList.add(pattern);</div><div class="line">        context.setStatus(<span class="string">"Aggregator Mapper:Grouping Patterns for "</span> + item);</div><div class="line">        context.write(<span class="keyword">new</span> Text(item), <span class="keyword">new</span> TopKStringPatterns(patternSingularList));</div><div class="line">      }</div><div class="line">    }</div><div class="line">    </div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　AggregatorReducer汇总了所有Key相同的item，然后按照支持度递减排序，最终输出Top K个频繁模式。</p>
<figure class="highlight [java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * </div><div class="line"> *  groups all Frequent Patterns containing an item and outputs the top K patterns</div><div class="line"> * containing that particular item</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AggregatorReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">TopKStringPatterns</span>,<span class="title">Text</span>,<span class="title">TopKStringPatterns</span>&gt; </span>{</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxHeapSize = <span class="number">50</span>;</div><div class="line">  </div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span>(Text key, Iterable&lt;TopKStringPatterns&gt; values, Context context) <span class="keyword">throws</span> IOException,</div><div class="line">                                                                                       InterruptedException {</div><div class="line">    TopKStringPatterns patterns = <span class="keyword">new</span> TopKStringPatterns();</div><div class="line">    <span class="keyword">for</span> (TopKStringPatterns value : values) {</div><div class="line">      context.setStatus(<span class="string">"Aggregator Reducer: Selecting TopK patterns for: "</span> + key);</div><div class="line">      patterns = patterns.merge(value, maxHeapSize);</div><div class="line">    }</div><div class="line">    context.write(key, patterns);</div><div class="line">    </div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setup</span>(Context context) <span class="keyword">throws</span> IOException, InterruptedException {</div><div class="line">    <span class="keyword">super</span>.setup(context);</div><div class="line">    Parameters params = <span class="keyword">new</span> Parameters(context.getConfiguration().get(<span class="string">"pfp.parameters"</span>, <span class="string">""</span>));</div><div class="line">    maxHeapSize = Integer.valueOf(params.get(<span class="string">"maxHeapSize"</span>, <span class="string">"50"</span>));</div><div class="line">    </div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="3-_讨论_">3. 讨论　</h3>
<p>　　并行化FP-Growth算法解决了大数据量时传统FP-Growth的性能瓶颈。除了并行化FP-Growth算法外，还有许多方法可以优化FP-Growth算法，比如并行化FP-Growth算法时考虑负载均衡，采用极大频繁项集和闭频繁项集表示频繁模式。</p>
<ul>
<li><p><strong> 极大频繁项集 </strong><br>　　极大频繁项集是这样的频繁项集，它的直接超集都不是频繁的。极大频繁项集形成了可以导出所有频繁项集的最小项集集合，但是极大频繁项集却不包含它们子集的支持度信息。</p>
</li>
<li><p>** 闭频繁项集 ××<br>　　如果项集的直接超集都不具有和它相同的支持度并且该项集的支持度大于或等于最小支持度阈值，则该项集是闭频繁项集。闭频繁项集提供了频繁项集的一种最小表示，该表示不丢失支持度信息。</p>
</li>
</ul>
<h3 id="4-_参考资料">4. 参考资料</h3>
<p>[1] 关联分析：FP-Growth算法. Mark Lin. datahunter2014. 2014. [<a href="http://datahunter2014.github.io/2014/10/26/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%EF%BC%9AFP-Growth%E7%AE%97%E6%B3%95/" target="_blank" rel="external">Link</a>]]</p>
<p>[2] PFP: Parallel FP-Growth for Query Recommendation. Haoyuan Li etc. RecSys ‘08 Proceedings of the 2008 ACM conference on Recommender systems. 2008. [<a href="http://dl.acm.org/ft_gateway.cfm?id=1454027&amp;type=pdf&amp;CFID=399593143&amp;CFTOKEN=12024195" target="_blank" rel="external">PDF</a>]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/10/27/Mahout源码分析：并行化FP-Growth算法/" data-id="t5y51p79gxu927uo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/关联分析/">关联分析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2014/10/26/关联分析：FP-Growth算法/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">关联分析：FP-Growth算法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/关联分析/" style="font-size: 10.00px;">关联分析</a><a href="/tags/机器学习/" style="font-size: 20.00px;">机器学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/10/27/Mahout源码分析：并行化FP-Growth算法/">Mahout源码分析：并行化FP-Growth算法</a>
          </li>
        
          <li>
            <a href="/2014/10/26/关联分析：FP-Growth算法/">关联分析：FP-Growth算法</a>
          </li>
        
          <li>
            <a href="/2014/10/26/分类问题中的“维数灾难”/">分类问题中的“维数灾难”</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget-wrap">
	<h3 class="widget-title">Friendly Links</h3>
	<div class="widget tag">	
		<ul class="entry">
			<li><a href="http://dozycfs.farbox.com/" title="Dozycfs">Dozycfs</a></li>
			<li><a href="http://coderart.cn/" title="Dancing In The Code">Dancing In The Code</a></li>
		</ul>
	</div>
</div>
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 Mark Lin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>